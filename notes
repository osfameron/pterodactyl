pterodactyl - Programmer's Text Editor for Winged Dinosaurs

Possibly "PTE" for Piece Table Editor
  (though the final data-structure may be tree based)

Uses a zipper or finger structure, which we'll call a "Dactyl"

Command:
  pterodactyl   (eeek!)
  ptero
  pt            (but platinum surfer)
  pd
  pc            (for pterodactyl client)
  wi            (short for "wingfinger", pleasant resonance with vi)

chunk into ~1K blocks?

[the]->[quick]->[brown]->[fox]->...

cursor is zipper.  Knows position by char, and by indexes (e.g. of newlines,
words, etc.)

indexing done by lexer (which can then feed into highlighter)

components:
  - lexer
  - highlighter

movements
  direction (f/b)
  inner/outer position (could be delimiter)

  e.g.
    "foo bar^ baz"
      /ba (forward and back)
         bbBBFff
      movement commands could go to:
        begin B
        end b
        begin b
        end F
        begin f
        end F
      and can act on whole area bBFf

    either:
      "inner" would be "BF" area
      "outer" would be "bBFf" area
    OR
      bBFf is calculated separately
      e.g.   <foo><bar> ^ </foo></bar>
                  BBBBBB F
      (should movement F/B commands be calculated from this?)

    defmulti dispatch?

    It looks like Movement commands should be:
      :: zipper -> zipper

    But this would allow badly behaved movement commands to return malformed
    zippers (e.g. behave destructively)

    Options:
      a) don't worry, just ask them nicely to be well behaved
        (this is fine, but other options are quite interesting)
      b) search with a fold of zipper movements, that returns true
        at the correct zipper.
        (this allows us to peek back/forth as required, but not change
        anything).
        But is it inefficient - e.g. if we can search more efficiently
        by using the index etc.
      c) communicate back to main function with a protocol
        e.g. by returning something like
          :next-piece   # discard this piece, giving me the zipper starting at
                        # next piece
          [5 2]         # inner at position 5, 2-long delimiter
          nil           # couldn't complete movement
        except that we might need to keep state, so would that have to be
        passed back and forth between functions?
      d) perhaps something like above, but the movement function accepts a
         function for next-piece (that updates an atom with the zipper)
         this allows the movement command to simply return the offset from
         current @zipper, maintaining its own state
          
Current vim bindings.  
  "!" means I think this is nonsense and may overwrite
  "?" means I'm pondering if this is needed

    lower                       upper
a  append                      append to end
b  back                        ?back (WORD)
c  change                      c$
d  delete                      d$
e  !forward (end)              !forward (end) (WORD)
f  find-in-line                like f, backwards
g  !misc (mostly alternates)   ?goto line
h  left                        !go to top (modulo scrolloff)
i  insert                      insert at beginning
j  down                        join
k  up                          ?lookup keyword
l  right                       !go to bottom (module scrolloff)
m  mark                        !go to middle (modulo scrolloff)
n  re-search                   re-search backwards
o  open line                   open line above
p  paste                       !paste before
q  !macro                      !Ex mode
r  replace char                replace mode
s  !subs character             !synonym cc
t  find-in-line-inner          like t, backwards
u  undo                        !weird vi-undo
v  visual mode                 linewise visual
w  forward (beginning)         like w (WORD)
x  delete char                 delete char backwards
y  yank                        syn yy (but more sense y$)
z  !misc (mostly zoom/folds)   !unused, but see ZZ
  
Notes:
  - should the WORD (inc punctuation) movements be an option?
  - e/E could move beginning/end of current word/selection instead
    (like O in visual mode)
  - t/f should find character anywhere, and n/N repeat that search, freeing
        up ,/;
     - or choose inner/outer as default, for example inner (t),
       and then use {go}{outer}t e.g. gat or gif for the alternative
  - U as "explore undo tree"?      
  - g should become "goto THING"
  - k could become various lookups (help, definition etc.)
  - should i/a/o take text objects?
      e.g. {with}{sentence}O (open newline before current sentence)
      ... or should default way be {text object}{grow/shrink}{operation} instead of other way around?
      ... which I guess is the visual-mode way of thinking about things, is
      that what I want?
      (ish, but I still want dd, D, C, d0, x)
  - macro recording can be a function call or composite keystroke
    (or alternatively q ok, and Q to call it)


So new mappings:

NORMAL
[] by word (or token)
() by sentence (or line)
{} by para (or block)
<>
"'
    lower                       upper
a  shrink-sel       A grow-sel         ^a unwrap?         ^A all-text menu
b  buffer ...       B ?
c  copy             C ?                                   ^C copy
d  ? (just dd and D?)
e  start-word/sel   E end-word/sel
f  find-char        F find-char backwards                 ^F find ...
g  go ...           G go to line                          ^G go menu
  gd (go definition) 
h  left             H ?                                   ^H help menu
i  insert           I insert after
j  down             J join
k  up               K ?
l  right            L ?
m  make ...         M mark                                ^M make menu
  mt (make test) me (eval) etc.
n  re-search        N re-search backwards                 ^N next qbe
o  open line        O open line above
  (or are these just sli / SI ?)
p  push (split)     P push (but follow onto the new line) ^P prev qbe
q  query ...        Q insert template                     ^Q template menu
  q8, qd (jump to definition)
r  replace char/sel R replace mode                        ^R Redo
s  select (visual)  S s$                                  ^S save
t  transform ...    T toggle case                         ^T open file
  t- t_ tc (snake kebab camel), tu tl (case), tr (reverse), tf (format)
u  undo             U ? (redo?)                           ^U gundo menu
v  paste            V paste special...                    ^V paste
w  window/buff ...  W ?                                   ^W close buffer
x  delete char/sel  X delete char backwards               ^X cut
y  yank mode        Y ?                                   ^Y redo
z  zoom ...         Z ?                                   ^Z undo
  e.g. view settings?
. repeat    ^. magic repeat  
, repeat move  ; repeat inverse move
| sse<ESC>
0 sle<ESC>
$ slE<ESC>

(file management is more destructive, so is managed with ^ commands)
in general most commands should be lower-case without modifiers
only ^ mappings should open a menu

TEXT OBJECTS
i/a compatibility with vim (though can be overridden with e/E)
l   line
[]w word
()s sentence
{}p paragraph/block
<>t tag
"d quote
'q
`b

insert mode
^n/^p auto-complete

PLUGIN notes

From emacs:
  - functions vs. "interactive" ones
  - interactive done as argument to 'defun' macro.  
  - options like "p" get the prefix argument (like Vim count?)
  - point, mark, mark-ring, exchange-point-and-mark, save-excursion
  - transient-mark-mode "makes Emacs behave sanely by using visible regions
    like other editors."
  - describe-function
  - major / minor modes, hooks
    - major seem like ftplugins
    - minor like generic plugins, but can be turned on/off
    - hooks allow e.g. "slime" (major) to turn on "eldoc" (minor)
    - see https://nathantypanski.com/blog/2014-08-03-a-vim-like-emacs-config.html
      for an example of getting mappings for a mode (IBuffer) to make sense
      with an alternative input strategy (Evil)
      can we do better than this?
      (e.g. keymapping -> generic intermediate layer -> plugin functionality)
  - package.el, cask, pallet (tools like Vundle?)
  - window/frame naming more logical (but now backwards from how everyone else
    does it)
  - ido ("interactively do things" like ctrl-p, helm etc.)
  - line numbers
  - scratch buffers
  - repls (and terminal emulators) within emacs
  - prompts, and how to disable them
  - echo area
  - melpa (use-package)
    :ensure  (auto fetches)
    :mode (defers loading till file extension found)
    :commands (define, don't run)
    :init (run immediately)
    :config (run after package loaded)
  - (visual-line-mode 1) "gives you sane word wrapping in almost all cases."

From vim
  - spell
  - omnicomplete
  - buffer-local mappings
  - autocommands, events
  - status lines
  - plugin layout
    - colors/
    - plugin/ (load once, on plugin load)
    - after/  (like plugin, but after internal files)
    - autoload/ (for lazy loading?)
    - ftdetect/
    - ftplugin/ (handles buffers of given filetype)
    - indent/  (as above, but for indentation)
    - compiler/ ???
    - doc/
    - syntax/
    - folding.vim
  - changing movement commands for filetypes (with nnoremap...)
  - calling external commands, e.g. filters
  - scratch splits
  - buffer types:
    nofile
    nowrite
    acwrite (autocommand write)
    quickfix
    help
    directory
    scratch
    unlisted
    (bufhidden, swapfile)
  - distribution  (clojars / github?)
  - <D-...> mappings, e.g. <D-V>
